#### 브루트포스(brute force)
- 문제를 해결하기 위해 가능한 모든 경우의 수를 탐색하면서 요구조건에 충족되는 결과만을 가져온다.(완전 탐색 알고리즘)
- 선형 구조를 전체적으로 탐색하는 순차탐색
  - 리스트에서 특정한 값을 찾는 알고리즘이다.
  - 리스트에서 찾고자하는 값을 맨 앞에서 부터 끝까지 찾아 나가는 것이다.
  - 검색할 리스트의 길이가 길면 비효율적이지만, 검색 방법 중 가장 단순하여 구현이 쉽다.
  - 정렬되지 않은 리스트에서도 사용 할 수 있다.
- 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS - Depth First Search)과 너비 우선 탐색(BFS - Breadth First Depth)

#### 정렬
- 선택정렬(Selection Sort)
  - 배열이 끝날때까지 첫번째 자리에 가장 작은 값을 넣고, 그 뒤 두번째 자리에 그 다음 작은 값을 선택해서 넣는다. 배열이 끝날때까지 반복한다.
- 버블정렬(Bubble Sort)
  - 현재 배열요소와 그 다음 배열 요소를 비교한 다음 조건에 맞으면 교환하는 방식의 정렬이다.
- 삽입정렬(Insertion Sort)
  - 현재 비교하고자 하는 타겟과 그 이전의 원소들과 비교하여 자리를 교환하는 방법이다.
  - 삽입 정렬의 전체적인 과정은 아래와 같다.
    1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들과 비교한다.(첫 번째 타겟은 두 번째 원소부터 시작한다.)
    2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작으면 위치를 서로 교환한다.
    3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.
- 셸 정렬(Shell Sort)
  - 삽입 정렬을 보완한 알고리즘이다.
  - 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른것에 착안
  - 과정
    1. 정렬해야 할 리스트의 각 k 번째 요소를 추출해서 부분 리스트를 만든다. 이때 k를 간격(gap)이라고 한다.
        - 간격의 초깃값: (정렬할 값의 수) / 2
        - 생성된 부분 리스트의 갯수는 gap과 같다.
    2. 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
        - 간격은 홀수로 하는 것이 좋다.
        - 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
    3. 간격 k 가 1이 될 때까지 반복한다.
- 퀵 정렬(Quick Sort)
  - 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
  - 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법이다.
  - 과정
    1. 리스트 안에 있는 한 요소를 선택한다. 이 원소를 피벗(pivot)이라고 한다.
    2. 피벗을 기준으로 피벗보다 작은 요소들은 피벗의 왼쪽으로 옮겨지고, 피벗보다 큰 요소들은 피벗의 오른쪽으로 옮긴다.
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
        - 분할된 부분 리스트에 대해서 순환호출을 이용하여 정렬을 반복한다.
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
    4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
- 힙 정렬(Heap Sort)
  - 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법이다.
  - 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
  - 과정
    1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
    2. 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장한다.
    3. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
- 합병 정렬(Merge Sort)
  - 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.
  - 분할 정복이란 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
  - 과정
    1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
    2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
    3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
    4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

#### 백트래킹(Backtracking)
- 퇴각검색
- 조건만족 즉, CSP(Constrain Satisfaction Problems)을 해결하기 위해 쓰인다.
- 모든 조합의 수를 살펴보는 것이지만 단, 조건이 만족할 때만이다.
- 반목문의 횟수까지 줄 일 수 있으므로 효율적이다.

#### 동적계획법(Dynamic Programming)
- 문제의 최적해를 구하거나 답의 개수를 세는 과정에 사용할 수 있는 알고리즘이다.
- 불필요한 계산을 줄이고, 효율적으로 최적해를 찾을 수 있다.
- 전체 문제를 작은 문제로 단순화한 다음 점화식으로 만들어 재귀적인 구조를 활용해서 전체 문제를 해결하는 방식이다.
  1. 전체 문제를 작은 문제로 단순화 한다. -> 부분 문제를 정의한다.
  2. 재귀적인 구조를 활용할 수 있는 점화식을 만든다. -> 점화식을 만든다.
  3. 작은 문제를 해결한 방법으로 전체 문제를 해결한다. -> 문제를 해결한다.
- 메모이제이션(Memoization): 함수의 값을 계산한 뒤 계산된 값을 배열에 저장하는 방식이다. 이렇게 하면 함수를 다시 호출하지 않고 값을 빠르게 가져 올 수 있다.
- Top-Down: 문제 풀이가 위에서 아래로 진행(메모이제이션 사용하는 방식)
- Bottom-Up: 문제 풀이가 아래에서 위로 진행(for 문을 이용해 처음값부터 계산해 나가는 방식)